% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotgroups.R
\name{plotgroups}
\alias{plotgroups}
\title{Plot several groups of repeated observations.}
\usage{
plotgroups(data, names, colors = NULL, legend.text = NULL,
  legend.col = NULL, legend.pars = list(font = 2), legend.lwd = NULL,
  names.split = NULL, names.italicize = NULL, names.style = c("plain",
  "combinatorial"), names.pch.cex = 1, names.pch = 19, names.adj = NA,
  names.margin = 0.5, names.rotate = NULL, features = NULL, range = 1.5,
  conf.level = 0.95, ci.fun = plotgroups.ci, cex.xlab = 1, ylim = NULL,
  legendmargin = NULL, plot.fun = plotgroups.boxplot,
  plot.fun.pars = list(), barwidth = 0.8, main = NULL, ylab = NULL,
  signif.test = NULL, signif.test.fun = t.test,
  signif.test.text = function(p) paste0("p=", formatC(p, digits = 3, format =
  "g")), signif.test.col = "black", signif.test.lwd = legend.lwd,
  signif.test.pars = legend.pars, extrafun.before = NULL,
  extrafun.after = NULL, ...)
}
\arguments{
\item{data}{list, each element is a vector of replicates for one combination of parameters, or
each element is a list containing a vector of replicates, in which case the data sets
will be plotted below each other in separate plots}

\item{names}{character vector of X axis labels}

\item{colors}{colors for plotting}

\item{legend.text}{character vector of the same length as \code{data} giving the group names.
A group of observations is identified by consecutive occurrence of the same name.}

\item{legend.col}{colors for group annotations. Defaults to plotting colors}

\item{legend.pars}{parameters for group annotation. Will be passed to \code{\link[base]{text}}}

\item{legend.lwd}{line width for grouping annotations. Defaults to \code{par("lwd")}}

\item{names.split}{character by which to split the \code{names}. Only useful in combination with
\code{names.italicize} or \code{names.style='combinatorial'}}

\item{names.italicize}{if a part of a \code{name} is to be written in italic text, the part is
identified by this character. I.e. The name is first split by \code{names.split}, each
fragment containing \code{names.italicize} is rendered in italics}

\item{names.style}{how the \code{names} are to be rendered.
\describe{
      \item{plain}{each name will be written as-is below the plot}
      \item{combinatorial}{names will be split by \code{names.split}, unique strings will be
            printed at the bottom-left, and observations whose name contains the string will
            be identified by prining \code{names.pch} below the respective bar. Useful if e.g.
           assaying different combinations of single/double/triple knock-outs.}
           }}

\item{names.pch.cex}{character expansion factor for \code{names.pch}}

\item{names.pch}{character to be used for annotation of observations when
\code{names.style='combinatorial'}}

\item{names.adj}{text adjustment for \code{names} or \code{names.pch}, depending on
\code{names.style}.See \code{\link[base]{text}}. Defaults to 1 for
\code{names.style = 'plain'}, unless \code{names.rotate = 0}, in which case it
defaults to 0.5. Defaults to 0.5 for \code{names.style='combinatorial'}.}

\item{names.margin}{spacing between the bottom edge of the plot and the annotation, in inches}

\item{names.rotate}{only used when \code{names.style='plain'}. Degrees by which to rotate the
annotation strings.}

\item{features}{which features of the sample distributions to plot. Availability of features
depends on \code{plot.fun} Can contain any combination of the following:
\describe{
          \item{median}{the median}
          \item{box}{the first and third quartiles}
          \item{iqr}{the most extreme data point no more than \code{range} times the
                     interquartile range away from the \code{box}}
          \item{mean}{the mean}
          \item{sd}{mean \eqn{\pm} standard deviation}
          \item{sem}{mean \eqn{\pm} standard error of the mean}}
Can be a list containing character vectors, in which case the specified feature set will
apply to the corresponding plot if multiple data sets are plotted (see examples). Will be
recycled to the number of plots.}

\item{range}{determines how far the the \code{iqr} whiskers will extend out from the box,
if they are to be plotted. Will be recycled to the number of plots.}

\item{conf.level}{Confidence level for plotting of confidence intervals. Will be recycled to the
number of plots}

\item{ci.fun}{Function to compute confidence intervals. Will be recycled to the number of plots.
Must accept five arguments:
\describe{
          \item{data}{Numeric vector containing data for one group}
          \item{mean}{Precomputed mean of the sample}
          \item{se}{Precomputed standard error of the mean of the sample}
          \item{ndata}{Number of observations}
          \item{conf.level}{Confidence level}}
If \code{data} is given, \code{mean}, \code{se}, and \code{ndata} are not used,
but calculated from the data. If \code{data} is omitted, all of \code{mean},
\code{se}, and \code{ndata} must be given. Defaults to \code{plotgroups.ci}, which computes
confidence intervals using the t statistics.}

\item{cex.xlab}{character expansion factor for X axis annotation}

\item{ylim}{Y axis limits. Will be determined automatically if \code{NULL}. If not \code{NULL} but
only one limit is finite, the other will be determined automatically. Can be a list containing
numeric vectors, in which case the limits will apply to the corresponding plot if multiple
data sets are plotted. Will be recycled to the number of plots.}

\item{legendmargin}{spacing between the upper-most data point/feature and the upper edge of the
plot, required for group annotation. Will be determined automatically if \code{NULL}}

\item{plot.fun}{function to do the actual plotting. See \code{\link{plotgroups.boxplot}},
\code{\link{plotgroups.beeswarm}}, \code{\link{plotgroups.barplot}},
\code{\link{plotgroups.vioplot}}. Can be a list containing functions, in which case the
functions will apply to the corresponding plot.}

\item{plot.fun.pars}{additional parameters to pass to \code{plot.fun}}

\item{barwidth}{width of the individual bars/boxes etc. as fraction of 1}

\item{main}{main title}

\item{ylab}{Y axis label. Will be recycled to the number of plots.}

\item{signif.test}{list of 2-element integer vectors giving the elements of \code{data} to be
tested for significant differences. Can be a list of lists, in which case each element
will apply to the corresponding plot if multiple data sets are plotted.}

\item{signif.test.fun}{function to perform the significance testing. Must accept 2 vectors and
return a list containing at least the element \code{p.value}. Can be a list of functions,
in which case each element will apply to the corresponding plot if multiple data sets
are plotted.}

\item{signif.test.text}{function accepting a p-value and returning a formatted string to be used
for plotting or \code{NULL} if this p-value is not to be plotted (e.g. if it is not
significant). Can be a list of functions, in which case each element will apply to the
corresponding plot if multiple data sets are plotted.}

\item{signif.test.lwd}{line width for p-value annotations. Can be a list, in which case the lwd
will apply to the corresponding plot if multiple data sets are plotted.}

\item{signif.test.pars}{parameters for group annotation. Will be passed to \code{\link[base]{text}}.
Can be a list of lists, in which case each element will apply to the corresponding
plot if multiple data sets are plotted.}

\item{extrafun.before}{additional function to call after the coordinate system has been set up, but
before plotting, e.g. to add a background grid to the plot. Can be a list of functions, in
which case each element will apply to the corresponding plot if multiple data sets are
plotted.}

\item{extrafun.after}{additional function to call after plotting, e.g. to add additional elements
to the plot. Can be a list of functions, in which case each element will apply to the
corresponding plot if multiple data sets are plotted.}

\item{...}{additional parameters passed to \code{\link[base]{par}}}
}
\value{
list with the following components:
        \item{stats}{summary statistics of the data.}
        \item{plotfun}{Return value of \code{plot.fun}}
        If significance testing was performed, also contains a component \code{signiftest}, which
        is a list with elements ordered by \code{signif.test} with the following components:
        \item{test}{return value of the testing function}
        \item{label}{return value of \code{signif.test.text}}
}
\description{
Plot several groups of repeated observations, e.g. abundance/half-life of several
proteins each observed in several cell lines in several replicates. Observations can be grouped
either by protein (in which case cell lines will be annotated as X axis labels
and proteins above the plot) or by cell line. Related parameters can be plotted in separate plots
below each other, sharing the groupings and annotations (see examples)
}
\details{
This is a wrapper function around \code{plot.fun}. It sets up the coordinate system, calls
\code{extrafun.before} followed by \code{plot.fun}, which does the actual plotting, and
\code{extrafun.after}. All three functions are passed the follwing arguments:
\describe{
          \item{data}{the \code{data} argument passed to \code{plotgroups}}
          \item{stats}{summary statistics of the data. List with the following components:
                       \describe{
                              \item{means}{means}
                              \item{sds}{standard deviations}
                              \item{sems}{standard errors of the mean}
                              \item{medians}{medians}
                              \item{boxmax}{third quartile}
                              \item{boxmin}{tirst quartile}
                              \item{iqrmax}{the maximal data point within \code{range} times
                                            the interquartile range of \code{boxmax}}
                              \item{iqrmin}{the minimal data point within \code{range} times
                                            the interquartile range of \code{boxmmin}}}}
          \item{colors}{the \code{colors} argument passed to \code{plotgroups}}
          \item{features}{the \code{features} argument passed to \code{plotgroups}}
          \item{barwidth}{the \code{barwidth} argument passed to \code{plotgroups}}}
\code{plot.fun} is additionally passed the arguments given by \code{plot.fun.pars}.

Significance testing is performed by calling \code{signif.test.fun} with two vector arguments
containing the samples to be compared. \code{signif.test.fun} must return a list containing
a \code{p.value} element. The p value is passed as single argument to \code{signif.test.text}
which returns a character vector (or anything usable by \code{\link[graphix]{text}}).
}
\examples{
data <- list()
for (i in 1:14) data[[i]] <- rnorm(50, i, 0.5)
names <- rep(c('gene1', 'gene2', 'gene3', 'gene1 gene2', 'gene1 gene3', 'gene2 gene3', 'gene1 gene2 gene3'),
     times=2)
names2 <- as.character(rep(1:7,times=2))
names2[2] <- "abc\\nefg"
colors <- c("green", "blue")
legend.text <- rep(c("protein1", "protein2"), each=7)
plotgroups(data, names, colors, legend.text,
           plot.fun=plotgroups.beeswarm, features=c('mean', 'sd'), ylim=c(0,Inf))
plotgroups(data, names2, colors, legend.text,plot.fun=plotgroups.vioplot, ylim=c(0,Inf),
           names.rotate=0, names.adj=c(0.5, 1))
plotgroups(data, names, colors, legend.text,
           plot.fun=plotgroups.beeswarm, features=c('mean', 'sd'),
           names.style='combinatorial', names.split=" ", names.pch='\\u0394',
           plot.fun.pars=list(palpha=0.5, bxpcols="black"))
plotgroups(data, names, colors, legend.text,
           names.style='combinatorial', names.split=" ", names.pch='\\u0394')
plotgroups(data, names, colors, legend.text,
           names.style='combinatorial', names.split=" ", names.pch=19,
           main="test", plot.fun=plotgroups.barplot, features=c("mean", "sd"),
           plot.fun.pars=list(whiskerswidth=0.6))

names.pch <- rep('\\u0394', 24)
names.adj <- names.adj <- rep(list(c(0.5, 0)), 24)
names.rotate <- rep(0, 24)
names.pch[2] <- 'S158T'
names.adj[[2]] <- c(0, 0.5)
names.rotate[2] <- 90
plotgroups(data, names, colors, legend.text,names.style='combinatorial', names.split=" ",
           names.pch=names.pch, names.rotate=names.rotate, names.adj=names.adj)
## significance testing
plotgroups(data, names, colors, legend.text,names.style='combinatorial',
           names.split=" ", names.pch='\\u0394',
           signif.test=list(c(1,3), c(2,5), c(5,8), c(3,10)))
plotgroups(data, names, colors, legend.text,names.style='combinatorial',
           names.split=" ", names.pch='\\u0394',
           signif.test=list(c(1,3), c(2,5), c(5,8), c(3,10)),
           signif.test.text=function(p) {
                     if (p < 0.001) {
                         return('***')
                     } else if (p < 0.01) {
                         return('**')
                     } else if (p < 0.05) {
                         return('*')
                     } else {
                         return(NULL)
                     }})
## multiple plots
plotgroups(list(data, rev(data)), names, colors, legend.text,names.style='combinatorial',
           names.split=" ",names.pch=names.pch, names.rotate=names.rotate, names.adj=names.adj,
           ylim=c(0,Inf), ylab=c("data1", "data2"), main="test", features=list(NULL,
           c("median", "box")), plot.fun=list(plotgroups.boxplot, plotgroups.beeswarm),
           signif.test=list(NULL,list(c(1,3), c(2,5), c(5,8), c(3,10))))
}

