% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotgroups.R
\name{plotgroups}
\alias{plotgroups}
\title{Plot several groups of repeated observations.}
\usage{
plotgroups(data, names, colors = NULL, legend.text = NULL,
  legend.col = NULL, legend.pars = list(), legend.lwd = NULL,
  groups.spacing = 0, names.split = NULL, names.italicize = NULL,
  names.style = c("plain", "combinatorial"), names.pch.cex = 1,
  names.pch = 19, names.adj = NA, names.map.fun = NULL,
  names.margin = 0.5, names.rotate = NULL, names.placeholder = NA,
  features = NA, log = FALSE, range = 1.5, conf.level = 0.95,
  ci.fun = plotgroups.ci, cex.xlab = 1, ylim = NULL,
  legendmargin = NULL, plot.type = plotgroups.boxplot,
  plot.fun.pars = list(), barwidth = 0.8, main = NULL, ylab = NULL,
  signif.test = NULL, signif.test.fun = t.test,
  signif.test.text = function(p) paste0("p=", formatC(p, digits = 3, format =
  "g")), signif.test.col = "black", signif.test.lwd = legend.lwd,
  signif.test.pars = legend.pars, extrafun.before = NULL,
  extrafun.after = NULL, ...)
}
\arguments{
\item{data}{list, each element is a vector of replicates for one combination of parameters, or
each element is a list containing a vector of replicates, in which case the data sets
will be plotted below each other in separate plots}

\item{names}{character vector of X axis labels}

\item{colors}{colors for plotting}

\item{legend.text}{character vector of the same length as \code{data} giving the group names.
A group of observations is identified by consecutive occurrence of the same name.}

\item{legend.col}{colors for group annotations. Defaults to plotting colors}

\item{legend.pars}{parameters for group annotation. Will be passed to \code{\link[base]{text}}}

\item{legend.lwd}{line width for grouping annotations. Defaults to \code{par("lwd")}}

\item{groups.spacing}{extra space between the groups in user coordinates.}

\item{names.split}{character by which to split the \code{names}. Only useful in combination with
\code{names.italicize} or \code{names.style='combinatorial'}}

\item{names.italicize}{if a part of a \code{name} is to be written in italic text, the part is
identified by this character. I.e. The name is first split by \code{names.split}, each
fragment containing \code{names.italicize} is rendered in italics}

\item{names.style}{how the \code{names} are to be rendered.
\describe{
      \item{plain}{each name will be written as-is below the plot}
      \item{combinatorial}{names will be split by \code{names.split}, unique strings will be
            printed at the bottom-left, and observations whose name contains the string will
            be identified by printing \code{names.pch} below the respective bar. Useful if e.g.
           assaying different combinations of single/double/triple knock-outs.}
           }}

\item{names.pch.cex}{character expansion factor for \code{names.pch}}

\item{names.pch}{character to be used for annotation of observations when
\code{names.style='combinatorial'}}

\item{names.adj}{text adjustment for \code{names} or \code{names.pch}, depending on
\code{names.style}.See \code{\link[base]{text}}. Defaults to 1 for
\code{names.style = 'plain'}, unless \code{names.rotate = 0}, in which case it
defaults to 0.5. Defaults to 0.5 for \code{names.style='combinatorial'}.}

\item{names.map.fun}{Function mapping between names string and pch/cex/adj/rotate for the respective
combination. Useful for more complicated experimental layouts where different names.pch
must be used for different genes, see examples. Must accept six arguments:
\describe{
          \item{n}{String with the names combination to process}
          \item{split}{Default pattern to split by, as given by \code{names.split}}
          \item{pch}{Default pch, as given by \code{names.pch}}
          \item{cex}{Default cex, as given by \code{names.pch.cex}}
          \item{rotate}{Default rotate, as given by \code{names.rotate}}
          \item{adj}{Default adj, as given by \code{names.adj}}}
Must return a named list, with the names being the split genes that should be used to
label the rows, each element being itself a named list containing the plotting
parameters for that particular annotation, i.e. \code{pch}, \code{cex}, \code{rotate},
\code{adj}.}

\item{names.margin}{spacing between the bottom edge of the plot and the annotation, in inches}

\item{names.rotate}{Degrees by which to rotate the annotation strings.}

\item{names.placeholder}{Only used when \code{names.style='combinatorial'}. Placeholder character
to use when no annotation is present for the current sample and row. See examples.}

\item{features}{which features of the sample distributions to plot. Availability of features
depends on \code{plot.type} Can contain any combination of the following:
\describe{
          \item{median}{the median}
          \item{box}{the first and third quartiles}
          \item{iqr}{the most extreme data point no more than \code{range} times the
                     interquartile range away from the \code{box}}
          \item{mean}{the mean}
          \item{sd}{mean \eqn{\pm} standard deviation}
          \item{sem}{mean \eqn{\pm} standard error of the mean}
          \item{ci}{confidence interval at \code{conf.level}}}
Can be a list containing character vectors, in which case the specified feature set will
apply to the corresponding plot if multiple data sets are plotted (see examples). Will be
recycled to the number of plots.}

\item{log}{Whether to plot the Y axis on log scale}

\item{range}{determines how far the the \code{iqr} whiskers will extend out from the box,
if they are to be plotted. Will be recycled to the number of plots.}

\item{conf.level}{Confidence level for plotting of confidence intervals. Will be recycled to the
number of plots}

\item{ci.fun}{Function to compute confidence intervals. Will be recycled to the number of plots.
Must accept five arguments:
\describe{
          \item{data}{Numeric vector containing data for one group}
          \item{mean}{Precomputed mean of the sample}
          \item{se}{Precomputed standard error of the mean of the sample}
          \item{ndata}{Number of observations}
          \item{conf.level}{Confidence level}}
If \code{data} is given, \code{mean}, \code{se}, and \code{ndata} are not used,
but calculated from the data. If \code{data} is omitted, all of \code{mean},
\code{se}, and \code{ndata} must be given. Defaults to \code{plotgroups.ci}, which computes
confidence intervals using the t statistics. Must return a numeric vector of length 2,
containing the lower and upper confidence bounds.}

\item{cex.xlab}{character expansion factor for X axis annotation}

\item{ylim}{Y axis limits. Will be determined automatically if \code{NULL}. If not \code{NULL} but
only one limit is finite, the other will be determined automatically. Can be a list containing
numeric vectors, in which case the limits will apply to the corresponding plot if multiple
data sets are plotted. Will be recycled to the number of plots.}

\item{legendmargin}{spacing between the upper-most data point/feature and the upper edge of the
plot, required for group annotation. Will be determined automatically if \code{NULL}}

\item{plot.type}{list containint three functions:
\describe{
          \item{plot}{function to do the actual plotting. See
                      \code{\link{plotgroups.boxplot}}, \code{\link{plotgroups.beeswarm}},
                      \code{\link{plotgroups.barplot}}, \code{\link{plotgroups.vioplot}}.}
          \item{ylim}{Function to calculate Y axis limits based on data and features.
                      Takes three arguments:\describe{
                              \item{data}{List of numeric vectors with data}
                              \item{stats}{Precomputed statistics}
                              \item{features}{Features to plot}}
                      Returns either a 2-element vector with Y limits or \code{NULL}, in
                      which case Y limits will be computed based on sensible defaults.}
          \item{features}{Function to check user-supplied feature lists for correctness
                      and compute default features, if necessary. Takes one argument
                      (the user-supplied feature character vector) and returns a
                      character vector with features to plot.}}
Can be a list of lists, in which case the elements will apply to the corresponding plot.}

\item{plot.fun.pars}{additional parameters to pass to \code{plot.type$plot}}

\item{barwidth}{width of the individual bars/boxes etc. as fraction of 1}

\item{main}{main title}

\item{ylab}{Y axis label. Will be recycled to the number of plots.}

\item{signif.test}{list of 2-element integer vectors giving the elements of \code{data} to be
tested for significant differences. Can be a list of lists, in which case each element
will apply to the corresponding plot if multiple data sets are plotted.}

\item{signif.test.fun}{function to perform the significance testing. Must accept 2 vectors and
return a list containing at least the element \code{p.value}. Can be a list of functions,
in which case each element will apply to the corresponding plot if multiple data sets
are plotted.}

\item{signif.test.text}{function accepting a p-value and returning a formatted string to be used
for plotting or \code{NULL} if this p-value is not to be plotted (e.g. if it is not
significant). Can be a list of functions, in which case each element will apply to the
corresponding plot if multiple data sets are plotted.}

\item{signif.test.lwd}{line width for p-value annotations. Can be a list, in which case the lwd
will apply to the corresponding plot if multiple data sets are plotted.}

\item{signif.test.pars}{parameters for group annotation. Will be passed to \code{\link[base]{text}}.
Can be a list of lists, in which case each element will apply to the corresponding
plot if multiple data sets are plotted.}

\item{extrafun.before}{additional function to call after the coordinate system has been set up, but
before plotting, e.g. to add a background grid to the plot. Can be a list of functions, in
which case each element will apply to the corresponding plot if multiple data sets are
plotted.}

\item{extrafun.after}{additional function to call after plotting, e.g. to add additional elements
to the plot. Can be a list of functions, in which case each element will apply to the
corresponding plot if multiple data sets are plotted.}

\item{...}{additional parameters passed to \code{\link[base]{par}}}
}
\value{
list with the following components:
        \describe{
                 \item{stats}{summary statistics of the data.}
                 \item{features}{Character vector of features actually plotted.}
                 \item{plotfun}{Return value of \code{plot.type$plot}}
                 \item{xcoords}{X coordinates of the data.}
                 \item{annotation.height}{Height of the annotation in inches.}
                 \item{annotation.width}{Width of the annotation in inches. If
                     \code{names.style='combinatorial'} this is the width of the left margin.}
                 \item{legendmargin}{Top margin required for the legend, in user coordinates.}
                 If significance testing was performed, also contains a component
                 \code{signiftest}, which is a list with elements ordered by
                 \code{signif.test} with the following components:
                 \describe{
                         \item{test}{return value of the testing function}
                         \item{label}{return value of \code{signif.test.text}}}}
}
\description{
Plot several groups of repeated observations, e.g. abundance/half-life of several
proteins each observed in several cell lines in several replicates. Observations can be grouped
either by protein (in which case cell lines will be annotated as X axis labels
and proteins above the plot) or by cell line. Related parameters can be plotted in separate plots
below each other, sharing the groupings and annotations (see examples)
}
\details{
This is a wrapper function around \code{plot.type$plot}. It sets up the coordinate system, calls
\code{extrafun.before} followed by \code{plot.type$plot}, which does the actual plotting, and
\code{extrafun.after}. All three functions are passed the following arguments:
\describe{
          \item{data}{the \code{data} argument passed to \code{plotgroups}}
          \item{at}{X coordinates of the data. Particularly important when groups.spacing != 0}
          \item{stats}{summary statistics of the data. List with the following components:
                       \describe{
                              \item{means}{means}
                              \item{sds}{standard deviations}
                              \item{sems}{standard errors of the mean}
                              \item{medians}{medians}
                              \item{boxmax}{third quartile}
                              \item{boxmin}{tirst quartile}
                              \item{iqrmax}{the maximal data point within \code{range} times
                                            the interquartile range of \code{boxmax}}
                              \item{iqrmin}{the minimal data point within \code{range} times
                                            the interquartile range of \code{boxmin}}
                              \item{cimax}{the upper confidence bound, computed by \code{ci.fun}
                                           according to \code{conf.level}}
                              \item{cimin}{the lower confidence bound, computed by \code{ci.fun}
                                           according to \code{conf.level}}
                              \item{range}{the range of the extreme data points within
                                           [\code{iqrmin}, \code{iqrmax}]}
                              \item{conf.level}{the confidence level at which \code{cimax},
                                                \code{cimin} apply}}}
          \item{colors}{the \code{colors} argument passed to \code{plotgroups}}
          \item{features}{the \code{features} argument passed to \code{plotgroups}}
          \item{barwidth}{the \code{barwidth} argument passed to \code{plotgroups}}}
\code{plot.type$plot} is additionally passed the arguments given by \code{plot.fun.pars}.

Significance testing is performed by calling \code{signif.test.fun} with two vector arguments
containing the samples to be compared. \code{signif.test.fun} must return a list containing
a \code{p.value} element. The p value is passed as single argument to \code{signif.test.text}
which returns a character vector (or anything usable by \code{\link[graphix]{text}}).
}
\examples{
data <- list()
for (i in 1:14) data[[i]] <- rnorm(50, i, 0.5)
names <- rep(c('gene1', 'gene2', 'gene3', 'gene1 gene2', 'gene1 gene3', 'gene2 gene3', 'gene1 gene2 gene3'),
     times=2)
names2 <- as.character(rep(1:7,times=2))
names2[2] <- "abc\\nefg"
colors <- c("green", "blue")
legend.text <- rep(c("protein1", "protein2"), each=7)
plotgroups(data, names, colors, legend.text,
           plot.type=plotgroups.beeswarm, features=c('mean', 'sd'), ylim=c(0,Inf))
plotgroups(data, names2, colors, legend.text,plot.type=plotgroups.vioplot, ylim=c(0,Inf),
           names.rotate=0, names.adj=c(0.5, 1))
plotgroups(data, names, colors, legend.text, log=TRUE,
           plot.type=plotgroups.beeswarm, features=c('mean', 'sd'),
           names.style='combinatorial', names.split=" ", names.pch='\\u0394',
           plot.fun.pars=list(palpha=0.5, bxpcols="black"))
plotgroups(data, names, colors, legend.text,
           names.style='combinatorial', names.split=" ", names.pch='\\u0394',
           names.placeholder='+')
plotgroups(data, names, colors, legend.text,
           names.style='combinatorial', names.split=" ", names.pch=19,
           main="test", plot.type=plotgroups.barplot, features=c("mean", "sd"),
           plot.fun.pars=list(whiskerswidth=0.6))

map.fun <- function(n, split, pch, cex, rotate, adj) {
               n <- strsplit(n, split, fixed=TRUE)[[1]]
               nlist <- lapply(n, function(x){
                                      if (x != "gene2") {
                                          list(pch=pch, cex=cex, rotate=rotate, adj=adj)
                                       } else {
                                           list(pch='S158T', cex=cex, rotate=90, adj=c(0,0.5))
                                       }
                                    })
                names(nlist) <- n
                nlist
}
plotgroups(data, names, colors, legend.text,names.style='combinatorial', names.split=" ",
           names.pch='\\u0394', names.map.fun=map.fun)
## significance testing
plotgroups(data, names, colors, legend.text,names.style='combinatorial',
           names.split=" ", names.pch='\\u0394',
           signif.test=list(c(1,3), c(2,5), c(5,8), c(3,10)))
plotgroups(data, names, colors, legend.text,names.style='combinatorial',
           names.split=" ", names.pch='\\u0394',
           signif.test=list(c(1,3), c(2,5), c(5,8), c(3,10)),
           signif.test.text=function(p) {
                     if (p < 0.001) {
                         return('***')
                     } else if (p < 0.01) {
                         return('**')
                     } else if (p < 0.05) {
                         return('*')
                     } else {
                         return(NULL)
                     }})
## multiple plots
plotgroups(list(data, rev(data)), names, colors, legend.text,names.style='combinatorial',
           names.split=" ",names.pch='\\u0394', names.map.fun=map.fun,
           ylim=c(0,Inf), ylab=c("data1", "data2"), main="test", features=list(NULL,
           c("median", "box")), plot.type=list(plotgroups.boxplot, plotgroups.beeswarm),
           signif.test=list(NULL,list(c(1,3), c(2,5), c(5,8), c(3,10))))
}

